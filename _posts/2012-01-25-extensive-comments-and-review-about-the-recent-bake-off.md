---
layout: post
title: Extensive comments and review about the recent bake-off of de novo genome assemblers
  "GAGE"
tags:
- Genomics
- De novo assembly
- Paper comments
categories:
- Paper comments
---
<p>During this week&#8217;s Genomics seminar at the Genome Cafe in the Biostats department, <a href="http://scholar.google.com/citations?user=sUVeH-4AAAAJ&amp;hl=en">Steven Salzberg</a> gave a talk on his team new published paper: <a href="http://www.ncbi.nlm.nih.gov/pubmed/22147368">GAGE: A critical evaluation of genome assemblies and assembly algorithms.</a> I worked on a few assembly projects during my time at <a href="http://www.wintergenomics.com/">Winter Genomics</a>, but that was not the main reason why I was immediately submerged into his talk. I think that it was due to his bold comments since comparing genome assemblers is a, hmm&#8230;, delicate issue. I really like the confidence he has on his work and the way he projects it when he talks. It might be too preachy for some, but I like it. Plus it helps that I completely agreed on two key points that differentiate GAGE from it&#8217;s competitors: <a href="http://cnag.bsc.es/">dnGASP</a> and <a href="http://assemblathon.org/">Assemblathon</a>.</p>
<p>First, GAGE uses real data sets instead of simulated ones. I know that some might argue that a given data set can have specific properties that are not general or that it&#8217;s biased to a certain assembler. It also feels a bit funny, because I started out assembling simulated data too. It certainly had its uses as I learnt a lot. But once you encounter a real data set you learn how complicated things can be, and it can be quite messy as no one gives you perfectly clean data. I haven&#8217;t read much about GAGE&#8217;s competitors, but regardless of how they simulate their data, I completely agree with Steven that GAGE has the advantage by using four real data sets. Plus, they were quite sensible when choosing the four data sets as they are Illumina data (the most common) with frequently used read sizes and library types. Note that even the bacterial genome have more than one replicon. </p>
<p>The second key point is that the GAGE team made public all the data and assembly <em>recipes</em> available through their <a href="http://gage.cbcb.umd.edu/">official site</a> (which has a great summary in from of a FAQ explaining the project and key differences). They have certainly made an effort to guarantee the reproducibility of their results, which is hard to do and hasn&#8217;t been done before. It&#8217;s a sad feeling that it took so long for someone to focus on reproducibility. So it feels wrong that they have to stress out how unique this feature is on their paper, but they definitely had to. Hm&#8230; can anyone reproduce the human genome assembly? I&#8217;m not talking about someone reading the paper and doing it on their institution computers, but someone from the author team. I hope the changelog is saved at least in some kind of repository.</p>
<p>Another important difference between GAGE and say Assemblaton, is that the for GAGE an in-house team ran the assemblers instead of asking the authors of each program to fine tune their results. If you had asked me a year ago, I would surely had supported the idea of asking the authors to run their programs. After all, even if you read all the documentation it&#8217;s the authors who know the best tricks on how to use their assemblers (or should be very good users). Yet, I can see the point that in reality it&#8217;s not the authors who run their code for each application. It&#8217;s a person or team of bioinformaticians (or a biologist struggling to death with UNIX) that has read the manual &amp; papers (hopefully) from a few tools and decided which is his favorite one. During this process they probably ran a few of the assemblers with a small parameter scan and compared the results. The GAGE pipeline is very similar and hence feels much real. They obviously did this process in a more rigorous way and made sure the conditions allowed comparing the assemblers.</p>
<p>One of the steps common to all of their <em>recipes</em> was to run <a href="http://www.ncbi.nlm.nih.gov/pubmed/21114842">Quake: quality-aware detection and correction of sequencing errors.</a> I didn&#8217;t know about this specific tool before, but I did know about the idea. Basically, you plot the distribution of the k-mers multiplicity from your data and do something to those that are possible errors (those k-mers that are unique or have very low multiplicity compared to the expected value); most commonly you try to correct them and if you can&#8217;t, you discard them. That&#8217;s a very broad explanation and I&#8217;m sure that interested readers will download the original paper. </p>
<p>Anyhow, the point is that they cleaned the data sets prior to using any assembler. I couldn&#8217;t agree more to the sentence:</p>

> High-quality data can produce dramatic differences in the results

<p>Running some kind of preprocessing cleaning tool should help, but you can&#8217;t do miracles with crappy data. </p>
<p>This post is getting huge, so I&#8217;ll jump to some points I&#8217;d like to highlight though it&#8217;ll still be very long.</p>
<p>First, I&#8217;m amazed by the simple concept that is &#8220;N50 corrected&#8221;. It does look complicated to calculate, but the idea of splitting contigs when an error (at least a 5 bp indel) is found (they have Sanger-sequence reference genomes for 3 of them) before calculating the N50 size is just great. It&#8217;s simple and very effective. By using this statistic and comparing it to the original N50 size you can clearly detect <em>aggressive</em> assemblers that don&#8217;t mind adding errors vs highly conservative ones. Then, comparing &#8220;N50 corrected&#8221; vs the number of errors (as in figure 6) is VERY informative. I just love that figure!</p>
<p>The result is a bit frustrating because the winner is ALLPATHS-LG. Don&#8217;t get me wrong, I think that they are doing great work (they introduced new statistics for comparing assemblies, they are exploiting library preparation more than the rest, etc) but it&#8217;s simply hard to come by a data set that meets ALLPATHS-LG&#8217; requirements.</p>
<p>Second, no matter which assembler you use, your result is going to contain lots of errors. There is no way around it, it&#8217;s a fact! Hm&#8230; unless you want tiny contigs (very conservative assemblers) which aren&#8217;t really useful. I think that it&#8217;ll be important to stress this out to consumers of the technology instead of fueling their wild dreams of high-quality finished (not draft) de novo assemblies. </p>
<p>Third, de <em>novo</em> genome assembly (specially for large genomes) is still a complicated endeavor. You shouldn&#8217;t take it lightly!</p>
<p>As you might have noticed, I found this paper (and the talk) to be very stimulating and interesting. And as I forgot to do so during the talk, <strong>thank you Salzberg et al. for taking a huge step in the right direction</strong>. It&#8217;ll surely help those working on the field and that at some point asked themselves:</p>

> * What will an assembly based on short reads look like?
> * Which assembly software will produce the best results?
> * What parameters should be used when running the software?

<p>A couple more notes:</p>
<ul><li>It&#8217;s sad, but <a href="http://www.ebi.ac.uk/~zerbino/velvet/">Velvet</a> didn&#8217;t perform as well as I hoped. I had been convinced for a while that it is one of the best assemblers out there. Plus I&#8217;m surprised that it couldn&#8217;t run on a 256&#160;GB machine for the bumble bee data set.</li>
<li>Take a look at the E-size statistic on the methods section of the paper. It&#8217;s interesting that it correlates well with N50 size. At times, I haven&#8217;t been too eager to select a best assembly on N50 size as it might not be one of the longest assemblies and I felt like I was wasting data. But it is a very reasonable summary statistic for such a hard problem.</li>
<li>I&#8217;m still curious on whether gap-closers like <a href="http://www.ncbi.nlm.nih.gov/sites/entrez/20388197?dopt=Abstract&amp;holding=f1000,f1000m,isrctn">IMAGE: Iterative Mapping and Assembly for Gap Elimination</a> (I don&#8217;t know why they didn&#8217;t include the name on their paper title &gt;.&lt;) correctly increase scaffold/contig length by <a href="http://genomebiology.com/2010/11/4/R41/figure/F1">re-assembling local <em>border</em> paired-reads</a>.</li>
<li>Check the websites of the competitors. GAGE looks more complete to me and I&#8217;m quite surprised dnGASP doesn&#8217;t include links to the other sites! The <a href="https://twitter.com/#!/gagecompetition">GAGE twitter</a> might be a bit too much (plus it seems abandoned).</li>
<li><a href="http://www.nature.com/news/2011/110323/full/471425a.html">Here is a news commentary </a>which talks about the three competitors.</li>
<li>I found it funny when Salzberg declared a winner in the talk, but it&#8217;s surely takes some guts to do so and I agree that it had to be done after such a rigorous comparison (or &#8220;bake-off&#8221; ^_^).</li>
<li>From the advice section in Genomics 2011 (<a href="http://fellgernon.tumblr.com/post/16368703139/commenting-genomics-in-2011#.Tx922ePOzIw">check my long post about it</a>), &#8220;Published is better than perfect&#8221;. Results from a bake-off like GAGE are going to change quickly since new updates are released quickly, but they are very helpful!!!</li>
</ul>
